data_collectors = c("Collector 1", "Collector2"),
questionnaire_description = "Questionaire contained the following sections: ... ",
contacts_list = list(list(name = "Curation team", affiliation = "UNHCR", email = "xxx@xxx.org"),
list(name = "Another team", affiliation = "UNHCR", email = "xxx2@xxx.org")),
publication_year = 2021
)
# create the survey passing the metadata list
a_response <- mdl_survey_create(
survey_metadata_list = a_survey_metadata,
enum_collection = mdl_enum_collection$MENA,
enum_survey_access_policy = mdl_enum_survey_access_policy$`Licensed use files`,
published = FALSE,
overwrite = FALSE
)
# get a test data frame and label it with package labelled
# alternatively, you can import a data frame from a Stata file using haven::read_dta
a_data_frame <- iris
labelled::var_label(a_data_frame) <- list(Sepal.Length =  "Length of sepal", Sepal.Width = "Width of sepal", Petal.Length = "Length of petal", Petal.Width = "Width of Petal", Species = "Species")
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
# call API
httpResponse <- httr::DELETE(url,
httr::add_headers("X-API-KEY" = mdl_api_get_key()),
body = options,
encode = "json"
)
mdl_api_open_documentation
mdl_api_open_documentation()
# create the metadata for a new survey
a_survey_metadata <-  mdl_survey_generate_metadata_list(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
title = "A Test Survey, 2021",
country_ISO_alpha3_codes = c("ETH"),
enum_survey_study_type = mdl_enum_survey_study_type$`Sample Frame, Households [sf/hh]`,
series_information = "A series test...",
abstract = "This is a test survey create using APIs...",
enum_survey_kind_of_data = mdl_enum_survey_kind_of_data$`Sample survey data [ssd]`,
unit_of_analysis = "Household",
version_description = "v2.1: Edited, cleaned and anonymised data.",
version_date = "2021-07-04",
scope_description = "The scope includes: \n- household characteristics \n- dwellings",
enum_survey_topics = c(mdl_enum_survey_topics$Health, mdl_enum_survey_topics$Protection),
keywords = c("Keyword 1", "Keyword 2", "Keyword 3"),
geographic_coverage = "Whole country.",
universe = "All people of concern.",
primary_investigators = c("UNHCR"),
other_producers = c("Another organisation"),
sampling_description = "Simple sampling was applied...",
weighting_description = "Weight was calculated in the following manner...",
collection_date_start = "2020-12-12",
collection_date_end = "2021-01-01",
enum_survey_collection_mode = mdl_enum_survey_collection_mode$`Face-to-face [f2f]`,
data_collection_notes = "Enumerators took a 3-day course...",
data_collectors = c("Collector 1", "Collector2"),
questionnaire_description = "Questionaire contained the following sections: ... ",
contacts_list = list(list(name = "Curation team", affiliation = "UNHCR", email = "xxx@xxx.org"),
list(name = "Another team", affiliation = "UNHCR", email = "xxx2@xxx.org")),
publication_year = 2021
)
# create the survey passing the metadata list
a_response <- mdl_survey_create(
survey_metadata_list = a_survey_metadata,
enum_collection = mdl_enum_collection$MENA,
enum_survey_access_policy = mdl_enum_survey_access_policy$`Licensed use files`,
published = FALSE,
overwrite = FALSE
)
# create the survey passing the metadata list
a_response <- mdl_survey_create(
survey_metadata_list = a_survey_metadata,
enum_collection = mdl_enum_collection$MENA,
enum_survey_access_policy = mdl_enum_survey_access_policy$`Licensed use files`,
published = FALSE,
overwrite = TRUE
)
# get a test data frame and label it with package labelled
# alternatively, you can import a data frame from a Stata file using haven::read_dta
a_data_frame <- iris
labelled::var_label(a_data_frame) <- list(Sepal.Length =  "Length of sepal", Sepal.Width = "Width of sepal", Petal.Length = "Length of petal", Petal.Width = "Width of Petal", Species = "Species")
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
options = list(
file_id = "hh")
survey_idno <- "UNHCR_ETH_2021_TEST_v2.1"
# specify url
url <-  paste(mdl_api_get_url(), "datasets", "datafiles", survey_idno, sep = "/")
# call API
httpResponse <- httr::PUT(url,
httr::add_headers("X-API-KEY" = mdl_api_get_key()),
body = options,
encode = "json"
)
# call API
httpResponse <- httr::POST(url,
httr::add_headers("X-API-KEY" = mdl_api_get_key()),
body = options,
encode = "json"
)
# call API
httpResponse <- httr::PUT(url,
httr::add_headers("X-API-KEY" = mdl_api_get_key()),
body = options,
encode = "json"
)
survey_create_data_file
#'
#' @return API call response.
#'
#' @param survey_idno The unique identifier of an existing survey, e.g.: UNHCR_ETH_2020_SENS_v2.1
#' @param data_frame A data frame containing the data.
#' @param file_id An unique identifier for the file containing the variables metadata. If not provided, the name of the file will be used. If provided, the ID should only include alphanumeric chars. This ID is not shown in the platform, it is mostly used for fetching or modifying the metadata in a second moment.
#' @param file_name The name of the file containing the variables as you want it to be shown in the platform to the final user.
#' @param file_description Brief description of the file, as you want it to be shown in the platform to the final user.
#'
#' @export
mdl_vars_create_from_dataframe <- function(survey_idno, data_frame, file_id, file_name, file_description){
#create data file that will contain the variables
a_response <- survey_create_data_file(
survey_idno = survey_idno,
file_id = file_id,
file_name = file_name,
description = file_description,
case_count = nrow(data_frame),
var_count = ncol(data_frame)
)
# iterate over variables
var_options_list <- list()
for(i in 1:ncol(data_frame)){
#print(i)
# get basic info
a_var <- data_frame[[i]]
a_var_class <- class(a_var)[1]
a_var_id <- paste0(file_id, "_V", i)
a_var_name <- names(data_frame)[i]
a_var_label <- labelled::var_label(a_var, unlist = TRUE)
a_var_label <- ifelse(is.null(a_var_label), "", a_var_label)
# set basic options
a_var_options <- list(
vid = a_var_id,
name = a_var_name,
labl = a_var_label
)
##### CHARACTER
if(a_var_class == "character"){
a_var_options$var_intrvl = "discrete"
a_var_options$var_format = list(type = "Character")
a_var_options$var_sumstat = data.frame(value  = c(sum(!is.na(a_var)), sum(is.na(a_var))), type = c("vald", "invd"))
}
##### FACTOR
if(a_var_class %in% c("haven_labelled", "factor")){
# convert in case is from haven
a_var <- haven::as_factor(a_var)
# get basic info
n_missing_values <-  sum(is.na(a_var))
a_var_options$var_intrvl = "discrete"
a_var_options$var_format = list(type = "Factor")
a_var_options$var_sumstat = data.frame(value  = c(length(a_var) - n_missing_values, n_missing_values), type = c("vald", "invd"))
if(sum(!is.na(a_var), na.rm = TRUE) > 0){ # add min and max if there is at least a value
a_var_options$var_val_range = list(min = 1, max = nlevels(a_var))
}
# define first part of categories
cat_table <- table(a_var)
cat_values <- as.character(1 : nlevels(a_var))
cat_labels <- names(cat_table)
cat_is_missing <- rep("", nlevels(a_var))
if(n_missing_values > 0) {
cat_values <- c(cat_values, "Missing value")
cat_labels <- c(cat_labels, NA)
cat_is_missing <- c(cat_is_missing, "Y")
}
# get frequency stats
cat_freq <- as.vector(cat_table)
cat_freq <- if(n_missing_values > 0){append(cat_freq, n_missing_values)}else{cat_freq}
cat_stats <- list()
for(a_freq in cat_freq){
cat_stats <- c(cat_stats, list(data.frame(value = a_freq, type = "freq", wgtd = 0)))
}
# create options list
a_var_options$var_catgry <-
data.frame(value = cat_values, labl = cat_labels, is_missing = cat_is_missing)
a_var_options$var_catgry$stats <- cat_stats
}
##### INTEGER
if(a_var_class == "integer" || (a_var_class == "numeric" && isTRUE(all.equal(a_var, trunc(a_var))))){
# get basic info
n_missing_values <-  sum(is.na(a_var))
a_var_options$var_intrvl = "discrete"
a_var_options$var_format = list(type = "Integer")
a_var_options$var_sumstat = data.frame(value  = c(length(a_var) - n_missing_values, n_missing_values), type = c("vald", "invd"))
if(sum(!is.na(a_var), na.rm = TRUE)){ # add min and max if there is at least a value
a_var_options$var_val_range = list(min = min(a_var, na.rm = TRUE), max = max(a_var, na.rm = TRUE))
}
# if there are only few numbers, then show frequency, otherwise not, it would be too many (for example IDs)
if(length(unique(a_var)) <= 30) {
# define first part of categories
cat_table <- table(a_var)
cat_values <- names(cat_table)
cat_labels <- rep(NA, length(cat_values))
cat_is_missing <- rep("", length(cat_values))
if(n_missing_values > 0) {
cat_values <- c(cat_values, "Missing value")
cat_labels <- c(cat_labels, NA)
cat_is_missing <- c(cat_is_missing, "Y")
}
# get frequency stats
cat_freq <- as.vector(cat_table)
cat_freq <- if(n_missing_values > 0){append(cat_freq, n_missing_values)}else{cat_freq}
cat_stats <- list()
for(a_freq in cat_freq){
cat_stats <- c(cat_stats, list(data.frame(value = a_freq, type = "freq", wgtd = 0)))
}
# add frequencies to options
a_var_options$var_catgry <- data.frame(value = cat_values, labl = cat_labels, is_missing = cat_is_missing)
a_var_options$var_catgry$stats <- cat_stats
}
}
##### NUMERIC
if(a_var_class == "numeric" && !isTRUE(all.equal(a_var, trunc(a_var))) ){
# number of decimals to show for mean and st dev
number_of_decimals <- 2
# get basic info
n_missing_values <-  sum(is.na(a_var))
a_var_options$var_intrvl = "contin"
a_var_options$var_format = list(type = "Numeric")
if(sum(!is.na(a_var), na.rm = TRUE)){ # add min and max if there is at least a value
a_var_options$var_val_range = list(min = min(a_var, na.rm = TRUE), max = max(a_var, na.rm = TRUE))
}
a_var_options$var_sumstat = data.frame(value  = c(length(a_var) - n_missing_values,
n_missing_values,
round(mean(a_var, na.rm = TRUE), digits = number_of_decimals),
round(sd(a_var, na.rm = TRUE), digits = number_of_decimals)),
type = c("vald", "invd", "mean", "stdev"))
}
##### LOGICAL
if(a_var_class == "logical"){
# get basic info
n_missing_values <-  sum(is.na(a_var))
n_true <- sum(a_var, na.rm = TRUE)
n_false <- length(a_var) - n_missing_values - n_true
a_var_options$var_intrvl = "discrete"
a_var_options$var_format = list(type = "Logical")
a_var_options$var_sumstat = data.frame(value  = c(length(a_var) - n_missing_values, n_missing_values), type = c("vald", "invd"))
# define first part of categories
cat_table <- table(a_var)
cat_values <- c("0", "1")
cat_labels <- c("FALSE", "TRUE")
cat_is_missing <- rep("", 2)
# get frequency stats
cat_stats <- list()
cat_stats <- c(cat_stats, list(data.frame(value = n_false, type = "freq", wgtd = 0)))
cat_stats <- c(cat_stats, list(data.frame(value = n_true, type = "freq", wgtd = 0)))
if(n_missing_values > 0) {
cat_values <- c(cat_values, "Missing value")
cat_labels <- c(cat_labels, NA)
cat_is_missing <- c(cat_is_missing, "Y")
cat_stats <- c(cat_stats, list(data.frame(value = n_missing_values, type = "freq", wgtd = 0)))
}
#create options list
a_var_options$var_catgry <- data.frame(value = cat_values, labl = cat_labels, is_missing = cat_is_missing)
a_var_options$var_catgry$stats <- cat_stats
}
# add options to list of all vars options
var_options_list <- c(var_options_list, list(a_var_options))
}
# create all vars
survey_create_variable(survey_idno = survey_idno,
file_id = file_id,
var_metadata = var_options_list)
}
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains all the household data collected during the survey."
)
a_data_frame
labelled::var_label(a_data_frame) <- list(Sepal.Length =  "Length of sepal", Sepal.Width = "Width of sepal", Petal.Length = "Length of petal", Petal.Width = "Width of Petal", Species = "Species name")
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains all the household data collected during the survey."
)
?mdl_resource_upload_file_and_link
?mdl_vars_create_from_dta
getwd()
mdl_vars_create_from_dta(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
file_path = "C:\\Users\\SANSON\\Desktop/xxx.dta",
file_id = NA,
file_name = "tets",
file_description = "asdsad"
)
mdl_survey_download_ddi("UNHCR_ETH_2021_TEST_v2.1")
mdl_vars_create_from_dta(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
file_path = "C:\\Users\\SANSON\\Desktop/xxx.dta",
file_id = NA,
file_name = "tets",
file_description = "asdsad"
)
mdl_survey_download_ddi("UNHCR_ETH_2021_TEST_v2.1")
?mdl_survey_import_ddi
mdl_survey_import_ddi(
xml_file = "UNHCR_ETH_2021_TEST_v2.1x.xml",
rdf_file = NULL,
enum_collection = NULL,
enum_survey_access_policy = NULL
)
mdl_survey_import_ddi(
xml_file = "UNHCR_ETH_2021_TEST_v2.1x.xml",
rdf_file = NULL,
enum_collection = NULL,
enum_survey_access_policy = NULL,
published = FALSE,
overwrite = T
)
test_id <- "test_10"
?mdl_survey_generate_pdf
mdl_survey_generate_pdf
test_id <- "test_10"
# create the metadata for a new survey
a_survey_metadata <-  mdl_survey_generate_metadata_list(
survey_idno = test_id,
title = "A Test Survey, 2021",
country_ISO_alpha3_codes = c("ETH"),
enum_survey_study_type = mdl_enum_survey_study_type$`Sample Frame, Households [sf/hh]`,
series_information = "A series test...",
abstract = "This is a test survey create using APIs...",
enum_survey_kind_of_data = mdl_enum_survey_kind_of_data$`Sample survey data [ssd]`,
unit_of_analysis = "Household",
version_description = "v2.1: Edited, cleaned and anonymised data.",
version_date = "2021-07-04",
scope_description = "The scope includes: \n- household characteristics \n- dwellings",
enum_survey_topics = c(mdl_enum_survey_topics$Health, mdl_enum_survey_topics$Protection),
keywords = c("Keyword 1", "Keyword 2", "Keyword 3"),
geographic_coverage = "Whole country.",
universe = "All people of concern.",
primary_investigators = c("UNHCR"),
other_producers = c("Another organisation"),
sampling_description = "Simple sampling was applied...",
weighting_description = "Weight was calculated in the following manner...",
collection_date_start = "2020-12-12",
collection_date_end = "2021-01-01",
enum_survey_collection_mode = mdl_enum_survey_collection_mode$`Face-to-face [f2f]`,
data_collection_notes = "Enumerators took a 3-day course...",
data_collectors = c("Collector 1", "Collector2"),
questionnaire_description = "Questionaire contained the following sections: ... ",
contacts_list = list(list(name = "Curation team", affiliation = "UNHCR", email = "xxx@xxx.org"),
list(name = "Another team", affiliation = "UNHCR", email = "xxx2@xxx.org")),
publication_year = 2021
)
# create the survey passing the metadata list
a_response <- mdl_survey_create(
survey_metadata_list = a_survey_metadata,
enum_collection = mdl_enum_collection$MENA,
enum_survey_access_policy = mdl_enum_survey_access_policy$`Licensed use files`,
published = FALSE,
overwrite = TRUE
)
# get a test data frame and label it with package labelled
# alternatively, you can import a data frame from a Stata file using haven::read_dta
a_data_frame <- iris
labelled::var_label(a_data_frame) <- list(Sepal.Length =  "Length of sepal", Sepal.Width = "Width of sepal", Petal.Length = "Length of petal", Petal.Width = "Width of Petal", Species = "Species")
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = test_id,
data_frame = a_data_frame,
file_id = "hh",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
a_response <- mdl_survey_generate_pdf(survey_idno = test_id)
?mdl_survey_create
ddi_file <- mdl_survey_download_ddi(test_id)
ddi_file
# create a test file
write.csv(iris, "test_file.csv")
# upload a file and create a resource linked to it
a_response <- mdl_resource_upload_file_and_link(
survey_idno = "UNHCR_ETH_2021_TEST_v2.1",
file_path = "test_file.csv",
enum_resource_type = mdl_enum_resource_type$microdata,
title = "Household data",
description = "Contains the household data collected during the survey"
)
# download the file
ddi_file <- mdl_survey_download_ddi(test_id)
?mdl_survey_import_ddi
# upload a file and create a resource linked to it
a_response <- mdl_resource_upload_file_and_link(
survey_idno = test_id,
file_path = "test_file.csv",
enum_resource_type = mdl_enum_resource_type$microdata,
title = "Household data",
description = "Contains the household data collected during the survey"
)
# upload the ddi
a_response <- mdl_survey_import_ddi(
xml_file = test_id,
rdf_file = NULL,
enum_collection = NULL,
enum_survey_access_policy = NULL,
data_remote_url = NULL,
published = NULL,
overwrite = TRUE
)
# upload the ddi
a_response <- mdl_survey_import_ddi(
xml_file = ddi_file,
rdf_file = NULL,
enum_collection = NULL,
enum_survey_access_policy = NULL,
data_remote_url = NULL,
published = NULL,
overwrite = TRUE
)
# generate pdf
a_response <- mdl_survey_generate_pdf(survey_idno = test_id)
# creates the variables metadata for our survey starting from a data frame
# alternatively you can use mdl_vars_create_from_dta to use a Stata file instead
a_response <- mdl_vars_create_from_dataframe(
survey_idno = test_id,
data_frame = a_data_frame,
file_id = "hh2",
file_name = "Households",
file_description = "This file contains the household data collected during the survey."
)
# generate pdf
a_response <- mdl_survey_generate_pdf(survey_idno = test_id)
?mdl_survey_generate_pdf
#' This function creates the documentation PDF from the survey metadata and links a resource to it.
#'
#' @return API call response.
#'
#' @param survey_idno The identifier of the survey for which you want to generate the PDF, e.g.: UNHCR_ETH_2020_SENS_v2.1
#' @param variable_list Specifies if the PDF should include the variable list: 1 for yes, 0 for no.
#' @param variable_description Specifies if the PDF should include the variable description: 1 for yes, 0 for no.
#' @param external_resource Specifies if the PDF should include the external resources: 1 for yes, 0 for no.
#'
#' @export
mdl_survey_generate_pdf <- function(survey_idno,
#resource_title = "Documentation",
variable_list = 0,
variable_description = 0,
external_resource = 0)
{
# generate pdf
survey_generate_pdf_response <- survey_generate_pdf(
survey_idno = survey_idno,
variable_toc = variable_list,
variable_description = variable_description,
include_resources = external_resource,
language = "en"
)
return(survey_generate_pdf_response)
# # if successful, link a resource
# if(identical(survey_generate_pdf_response$status, "success")){
#     mdl_resource_add (
#         survey_idno = survey_idno,
#         filename = basename(survey_generate_pdf_response$output),
#         dctype = "doc/tec",
#         title = resource_title,
#         dcformat = "application/pdf",
#         description = NULL,
#         overwrite = "yes"
#     )
# }else {
#
# }
}
# generate pdf
a_response <- mdl_survey_generate_pdf(survey_idno = test_id)
